
# stdio.h(0p) — Linux manual page

## PROLOG  

This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.

## NAME  

stdio.h — standard buffered input/output

## SYNOPSIS  

```c
#include <stdio.h>
```

## DESCRIPTION  

Some of the functionality described on this reference page extends the ISO C standard. Applications shall define the appropriate feature test macro (see the System Interfaces volume of POSIX.1‐2017, Section 2.2, The Compilation Environment) to enable the visibility of these symbols in this header.

The `<stdio.h>` header shall define the following data types through `typedef`:

- `FILE`: A structure containing information about a file.
- `fpos_t`: A non-array type containing all information needed to specify uniquely every position within a file.
- `off_t`: As described in `<sys/types.h>`.
- `size_t`: As described in `<stddef.h>`.
- `ssize_t`: As described in `<sys/types.h>`.
- `va_list`: As described in `<stdarg.h>`.

The `<stdio.h>` header shall define the following macros which shall expand to integer constant expressions:

- `BUFSIZ`: Size of `<stdio.h>` buffers. This shall expand to a positive value.
- `L_ctermid`: Maximum size of character array to hold `ctermid()` output.
- `L_tmpnam`: Maximum size of character array to hold `tmpnam()` output.

The `<stdio.h>` header shall define the following macros which shall expand to integer constant expressions with distinct values:

- `_IOFBF`: Input/output fully buffered.
- `_IOLBF`: Input/output line buffered.
- `_IONBF`: Input/output unbuffered.

The `<stdio.h>` header shall define the following macros which shall expand to integer constant expressions with distinct values:

- `SEEK_CUR`: Seek relative to current position.
- `SEEK_END`: Seek relative to end-of-file.
- `SEEK_SET`: Seek relative to start-of-file.

The `<stdio.h>` header shall define the following macros which shall expand to integer constant expressions denoting implementation limits:

- `{FILENAME_MAX}`: Maximum size in bytes of the longest pathname that the implementation guarantees can be opened.
- `{FOPEN_MAX}`: Number of streams which the implementation guarantees can be open simultaneously. The value is at least eight.
- `{TMP_MAX}`: Minimum number of unique filenames generated by `tmpnam()`. Maximum number of times an application can call `tmpnam()` reliably. The value of `{TMP_MAX}` is at least 25. On XSI-conformant systems, the value of `{TMP_MAX}` is at least 10000.

The `<stdio.h>` header shall define the following macro which shall expand to an integer constant expression with type `int` and a negative value:

- `EOF`: End-of-file return value.

The `<stdio.h>` header shall define NULL as described in `<stddef.h>`.

The `<stdio.h>` header shall define the following macro which shall expand to a string constant:

- `P_tmpdir`: Default directory prefix for `tempnam()`.

The `<stdio.h>` header shall define the following macros which shall expand to expressions of type "pointer to `FILE`" that point to the `FILE` objects associated, respectively, with the standard error, input, and output streams:

- `stderr`: Standard error output stream.
- `stdin`: Standard input stream.
- `stdout`: Standard output stream.

The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.

```c
void     clearerr(FILE *);
char    *ctermid(char *);
int      dprintf(int, const char *restrict, ...);
int      fclose(FILE *);
FILE    *fdopen(int, const char *);
int      feof(FILE *);
int      ferror(FILE *);
int      fflush(FILE *);
int      fgetc(FILE *);
int      fgetpos(FILE *restrict, fpos_t *restrict);
char    *fgets(char *restrict, int, FILE *restrict);
int      fileno(FILE *);
void     flockfile(FILE *);
FILE    *fmemopen(void *restrict, size_t, const char *restrict);
FILE    *fopen(const char *restrict, const char *restrict);
int      fprintf(FILE *restrict, const char *restrict, ...);
int      fputc(int, FILE *);
int      fputs(const char *restrict, FILE *restrict);
size_t   fread(void *restrict, size_t, size_t, FILE *restrict);
FILE    *fre

open(const char *restrict, const char *restrict, FILE *restrict);
int      fscanf(FILE *restrict, const char *restrict, ...);
int      fseek(FILE *, long, int);
int      fseeko(FILE *, off_t, int);
int      fsetpos(FILE *, const fpos_t *);
long     ftell(FILE *);
off_t    ftello(FILE *);
int      ftrylockfile(FILE *);
void     funlockfile(FILE *);
size_t   fwrite(const void *restrict, size_t, size_t, FILE *restrict);
int      getc(FILE *);
int      getchar(void);
int      getc_unlocked(FILE *);
int      getchar_unlocked(void);
ssize_t  getdelim(char **restrict, size_t *restrict, int, FILE *restrict);
ssize_t  getline(char **restrict, size_t *restrict, FILE *restrict);
char    *gets(char *);
FILE    *open_memstream(char **, size_t *);
int      pclose(FILE *);
void     perror(const char *);
FILE    *popen(const char *, const char *);
int      printf(const char *restrict, ...);
int      putc(int, FILE *);
int      putchar(int);
int      putc_unlocked(int, FILE *);
int      putchar_unlocked(int);
int      puts(const char *);
int      remove(const char *);
int      rename(const char *, the char *);
int      renameat(int, the char *, int, the char *);
void     rewind(FILE *);
int      scanf(const char *restrict, ...);
void     setbuf(FILE *restrict, char *restrict);
int      setvbuf(FILE *restrict, char *restrict, int, size_t);
int      snprintf(char *restrict, size_t, the char *restrict, ...);
int      sprintf(char *restrict, the char *restrict, ...);
int      sscanf(const char *restrict, the char *restrict, ...);
char    *tempnam(const char *, the char *);
FILE    *tmpfile(void);
char    *tmpnam(char *);
int      ungetc(int, FILE *);
int      vdprintf(int, the char *restrict, va_list);
int      vfprintf(FILE *restrict, the char *restrict, va_list);
int      vfscanf(FILE *restrict, the char *restrict, va_list);
int      vprintf(const char *restrict, va_list);
int      vscanf(const char *restrict, va_list);
int      vsnprintf(char *restrict, size_t, the char *restrict, va_list);
int      vsprintf(char *restrict, the char *restrict, va_list);
int      vsscanf(const char *restrict, the char *restrict, va_list);
```
---
## Windows "Cheat Sheet" for Programmers

### File I/O

- **File Paths:**
  - Uses backslashes (`\`) as separators.
  - Drive letters (e.g., `C:\Windows\System32`).
  - Environment variables: Use `%VARIABLE_NAME%`.
- **fopen, fread, fwrite, etc.:**
  - Largely function the same way as their POSIX counterparts.
  - Specific text vs. binary handling modes available ('t' vs. 'b').
- **Preferred Alternatives:**
  - Consider the Windows API functions like `CreateFile`, `ReadFile`, `WriteFile` for greater control over file handles and low-level I/O.

### Standard Input, Output, Error (stdin, stdout, stderr)

- **Handles:** Windows uses file handles instead of raw file descriptors.
    - `GetStdHandle(STD_INPUT_HANDLE)`
    - `GetStdHandle(STD_OUTPUT_HANDLE)`
    - `GetStdHandle(STD_ERROR_HANDLE)`
- **Console I/O:**
    - `ReadConsole`, `WriteConsole` for text console interaction.
- **File-like Usage:** You can often map standard file handles to some functions that expect POSIX-style file descriptors. This is not universally safe!

### Process Management

- **Process Creation:** 
  - `CreateProcess` is the primary way to launch new processes. 
  - More complex than POSIX `fork`/`exec` model.
- **Pipes:**
  - Windows has named pipes with some different semantics compared to POSIX pipes.
  - Used via `CreateNamedPipe`, `ConnectNamedPipe`.

### Threads

- **Thread Creation:** `CreateThread` for starting new threads.
- **Synchronization:**  
  - Uses critical sections, mutexes, semaphores (e.g., `EnterCriticalSection`, `CreateMutex`). 

### Windows-Specific Concepts

- **Windows Registry:** Hierarchical database for system and application settings. Use functions like `RegOpenKeyEx`, `RegSetValueEx`.
- **Windows Services:** Applications running in the background. Use the Service Control Manager API.
- **COM (Component Object Model):** Framework for creating reusable software components.
- **.NET Framework / .NET Core:** Managed development environments; provide a large class library distinct from traditional Win32/C++.

### Notable Exceptions

- **

Signal Handling:** Windows does not have direct equivalents to POSIX signals. You'll need structured exception handling (`__try __except`) or Windows-specific mechanisms.
- **fork():** Windows has no `fork()`. Use `CreateProcess` strategically for launching additional processes.  
- **POSIX-Specific functions:** Many functions with a `p` in their name (`pthreads`, functions specific to pipes) may not have exact equivalents.

## EXAMPLES  

Practical examples where portable alternatives might not suffice, focusing on scenarios that are unique to Windows or where Windows-specific APIs provide functionalities that standard C/C++ libraries do not cover. These examples will demonstrate how to use Windows-specific features effectively in situations where portable alternatives fall short.

### 1. Advanced File I/O Operations

In scenarios requiring detailed control over file access, sharing, security attributes, or asynchronous I/O operations, the Windows API functions like `CreateFile`, `ReadFile`, `WriteFile`, and `Overlapped I/O` offer capabilities beyond what is available through standard C `fopen`, `fread`, and `fwrite`.

**Example: Creating a file with specific security attributes and asynchronous access**

```c
#include <windows.h>

void CreateFileExample() {
    HANDLE fileHandle;
    SECURITY_ATTRIBUTES secAttributes;

    secAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    // Use default security descriptor.
    secAttributes.lpSecurityDescriptor = NULL; 
    // Allow handle to be inherited.

    secAttributes.bInheritHandle = TRUE; 
    fileHandle = CreateFile(
        TEXT("example.txt"), // File name
        GENERIC_WRITE,       // Desired access (write access)
        0,                   // No sharing
        &secAttributes,      // Security attributes
        CREATE_NEW,          // Creation disposition
        FILE_FLAG_OVERLAPPED,// Flags/attributes (async I/O)
        NULL                 // No template file
    );

    if (fileHandle == INVALID_HANDLE_VALUE) {
        // Handle error condition
    }

    // Use fileHandle for asynchronous I/O operations...
    // Always close the handle when done.
    CloseHandle(fileHandle); 
}
```

### 2. Direct Console I/O

For applications that need direct control over the console (e.g., for writing Unicode characters or handling input/output in a non-standard way), `ReadConsole` and `WriteConsole` provide functionalities not available through `stdin`/`stdout`.

**Example: Writing Unicode text to the console**

```c
#include <windows.h>

void WriteUnicodeToConsole() {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    WCHAR text[] = L"Hello, 世界"; // Unicode text

    WriteConsole(hConsole, text, wcslen(text), NULL, NULL);
}
```

### 3. Process Creation and Management

When you need to create a process with specific starting conditions, environment variables, or startup information, `CreateProcess` offers a level of detail and control that cannot be matched by portable alternatives like `system()` or the POSIX `fork` and `exec`.

**Example: Launching a new process with custom environment and starting directory**

```c
#include <windows.h>

void CreateProcessExample() {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    // Set up environment block, startup directory, or other specific settings...

    if (!CreateProcess(
            TEXT("C:\\notepad.exe"),    // Application name
            NULL,                       // Command line
            NULL,                       // Process security attrs
            NULL,                       // Primary thread security attrs
            FALSE,                      // Handles are not inherited
            0,                          // Creation flags
            NULL,                       // Use parent's env block
            NULL,                       // Use parent's start dir
            &si,                        // Ptr to STARTUPINFO struct
            &pi                         // Ptr to PROCESS_INFORMATION struct
        )) {
        // Handle error condition
    }

    // Close process and thread handles when done
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}
```

### 4. Advanced Synchronization Techniques

In situations requiring complex synchronization among threads or processes, Windows offers a wide range of synchronization primitives like `Mutexes`, `Events`, `Semaphores`, and `Waitable Timers`, which provide capabilities beyond what is available through portable threading libraries.

**Example: Using a mutex to synchronize access to a resource**

```c
#include <windows.h>

HANDLE mutex;

void Initialize() {
    // Create a named mutex.
    mutex = CreateMutex(NULL, FALSE, TEXT("MyMutex"));
}

void ThreadFunction() {
    // Wait for the mutex for up to 10 seconds.
    DWORD dwWaitResult = WaitForSingleObject(mutex, 10000); // 10-second wait

    switch (dwWaitResult) {
        // The thread got mutex ownership.
        case WAIT_OBJECT_0:
            // Access shared resource.

            // Release ownership of the mutex.
            ReleaseMutex(mutex);
            break;

        // The thread got ownership of an abandoned mutex.
        // The database is in an indeterminate state.
        case WAIT_ABANDONED:
            return;
    }
}

void Cleanup() {
    CloseHandle(mutex); // Always clean up handles.
}
```

## APPLICATION USAGE  

None.

## RATIONALE  

None.

## FUTURE DIRECTIONS  

This should provide a comprehensive guide for developers navigating between Linux and Windows environments, highlighting key differences and offering Windows-specific insights alongside the POSIX standards.
## SEE ALSO  

The System Interfaces volume of POSIX.1‐2017, `<stdarg.h>`, `<stddef.h>`, `<sys/types.h>`

The Base Definitions volume of POSIX.1‐2017, `<stdio.h>`

[fdopen](https://man7.org/linux/man-pages/man3/fdopen.3p.html), [feof](https://man7.org/linux/man-pages/man3/feof.3p.html)[ferror](https://man7.org/linux/man-pages/man3/ferror.3p.html), [fflush](https://man7.org/linux/man-pages/man3/fflush.3phtml), [fgetc](https://man7.org/linux/man-pages/man3/fgetc.3p.html), [fgetpos](https://man7.org/linux/man-pages/man3fgetpos.3p.html), [fgets](https://man7.org/linux/man-pages/man3/fgets.3p.html), [fileno](https://man7.org/linux/man-pagesman3/fileno.3p.html), [flockfile](https://man7.org/linux/man-pages/man3/flockfile.3p.html), [fmemopen](https://man7.orglinux/man-pages/man3/fmemopen.3p.html), [fopen](https://man7.org/linux/man-pages/man3/fopen.3p.html), [fprintf](https:/man7.org/linux/man-pages/man3/fprintf.3p.html), [fputc](https://man7.org/linux/man-pages/man3/fputc.3p.html), [fputs](https://man7.org/linux/man-pages/man3/fputs.3p.html), [fread](https://man7.org/linux/man-pages/man3/fread.3p.html)[freopen](https://man7.org/linux/man-pages/man3/freopen.3p.html), [fscanf](https://man7.org/linux/man-pages/man3/fscanf.3phtml), [fseek](https://man7.org/linux/man-pages/man3/fseek.3p.html), [fsetpos](https://man7.org/linux/man-pages/man3fsetpos.3p.html), [ftell](https://man7.org/linux/man-pages/man3/ftell.3p.html), [fwrite](https://man7.org/linux/man-pagesman3/fwrite.3p.html), [getc](https://man7.org/linux/man-pages/man3/getc.3p.html), [getchar](https://man7.org/linuxman-pages/man3/getchar.3p.html), [getc_unlocked](https://man7.org/linux/man-pages/man3/getc_unlocked.3p.html), [getdelim](https://man7.org/linux/man-pages/man3/getdelim.3p.html), [getopt](https://man7.org/linux/man-pages/man3/getopt.3p.html)[gets](https://man7.org/linux/man-pages/man3/gets.3p.html), [open_memstream](https://man7.org/linux/man-pages/man3open_memstream.3p.html), [pclose](https://man7.org/linux/man-pages/man3/pclose.3p.html), [perror](https://man7.org/linuxman-pages/man3/perror.3p.html), [popen](https://man7.org/linux/man-pages/man3/popen.3p.html), [putc](https://man7.org/linuxman-pages/man3/putc.3p.html), [putchar](https://man7.org/linux/man-pages/man3/putchar.3p.html), [puts](https://man7.orglinux/man-pages/man3/puts.3p.html), [remove](https://man7.org/linux/man-pages/man3/remove.3p.html), [rename](https://man7org/linux/man-pages/man3/rename.3p.html), [rewind](https://man7.org/linux/man-pages/man3/rewind.3p.html), [setbuf](https:/man7.org/linux/man-pages/man3/setbuf.3p.html), [setvbuf](https://man7.org/linux/man-pages/man3/setvbuf.3p.html), [stdin](https://man7.org/linux/man-pages/man3/stdin.3p.html), [system](https://man7.org/linux/man-pages/man3/system.3p.html)[tempnam](https://man7.org/linux/man-pages/man3/tempnam.3p.html), [tmpfile](https://man7.org/linux/man-pages/man3/tmpfile3p.html), [tmpnam](https://man7.org/linux/man-pages/man3/tmpnam.3p.html), [ungetc](https://man7.org/linux/man-pages/man3ungetc.3p.html), [vfprintf](https://man7.org/linux/man-pages/man3/vfprintf.3p.html), [vfscanf](https://man7.org/linuxman-pages/man3/vfscanf.3p.html)

COPYRIGHT  

Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.opengroup.org/unix/online.html.
