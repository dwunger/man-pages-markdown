
# stdio.h(0p) — Linux manual page

## PROLOG  

This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.

## NAME  

stdio.h — standard buffered input/output

## SYNOPSIS  

```c
#include <stdio.h>
```

## DESCRIPTION  

Some of the functionality described on this reference page extends the ISO C standard. Applications shall define the appropriate feature test macro (see the System Interfaces volume of POSIX.1‐2017, Section 2.2, The Compilation Environment) to enable the visibility of these symbols in this header.

The `<stdio.h>` header shall define the following data types through `typedef`:

- `FILE`: A structure containing information about a file.
- `fpos_t`: A non-array type containing all information needed to specify uniquely every position within a file.
- `off_t`: As described in `<sys/types.h>`.
- `size_t`: As described in `<stddef.h>`.
- `ssize_t`: As described in `<sys/types.h>`.
- `va_list`: As described in `<stdarg.h>`.

The `<stdio.h>` header shall define the following macros which shall expand to integer constant expressions:

- `BUFSIZ`: Size of `<stdio.h>` buffers. This shall expand to a positive value.
- `L_ctermid`: Maximum size of character array to hold `ctermid()` output.
- `L_tmpnam`: Maximum size of character array to hold `tmpnam()` output.

The `<stdio.h>` header shall define the following macros which shall expand to integer constant expressions with distinct values:

- `_IOFBF`: Input/output fully buffered.
- `_IOLBF`: Input/output line buffered.
- `_IONBF`: Input/output unbuffered.

The `<stdio.h>` header shall define the following macros which shall expand to integer constant expressions with distinct values:

- `SEEK_CUR`: Seek relative to current position.
- `SEEK_END`: Seek relative to end-of-file.
- `SEEK_SET`: Seek relative to start-of-file.

The `<stdio.h>` header shall define the following macros which shall expand to integer constant expressions denoting implementation limits:

- `{FILENAME_MAX}`: Maximum size in bytes of the longest pathname that the implementation guarantees can be opened.
- `{FOPEN_MAX}`: Number of streams which the implementation guarantees can be open simultaneously. The value is at least eight.
- `{TMP_MAX}`: Minimum number of unique filenames generated by `tmpnam()`. Maximum number of times an application can call `tmpnam()` reliably. The value of `{TMP_MAX}` is at least 25. On XSI-conformant systems, the value of `{TMP_MAX}` is at least 10000.

The `<stdio.h>` header shall define the following macro which shall expand to an integer constant expression with type `int` and a negative value:

- `EOF`: End-of-file return value.

The `<stdio.h>` header shall define NULL as described in `<stddef.h>`.

The `<stdio.h>` header shall define the following macro which shall expand to a string constant:

- `P_tmpdir`: Default directory prefix for `tempnam()`.

The `<stdio.h>` header shall define the following macros which shall expand to expressions of type "pointer to `FILE`" that point to the `FILE` objects associated, respectively, with the standard error, input, and output streams:

- `stderr`: Standard error output stream.
- `stdin`: Standard input stream.
- `stdout`: Standard output stream.

The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.

```c
void     clearerr(FILE *stream);
char    *ctermid(char *s);
int      dprintf(int fd, const char *restrict format, ...);
int      fclose(FILE *stream);
FILE    *fdopen(int fd, const char *mode);
int      feof(FILE *stream);
int      ferror(FILE *stream);
int      fflush(FILE *stream);
int      fgetc(FILE *stream);
int      fgetpos(FILE *restrict stream, fpos_t *restrict pos);
char    *fgets(char *restrict str, int size, FILE *restrict stream);
int      fileno(FILE *stream);
void     flockfile(FILE *stream);
FILE    *fmemopen(void *restrict buf, size_t size, const char *restrict mode);
FILE    *fopen(const char *restrict filename, const char *restrict mode);
int      fprintf(FILE *restrict stream, const char *restrict format, ...);
int      fputc(int c, FILE *stream);
int      fputs(const char *restrict str, FILE *restrict stream);
size_t   fread(void *restrict ptr, size_t size, size_t nmemb, FILE *restrict stream);
FILE    *freopen(const char *restrict filename, const char *restrict mode, FILE *restrict stream);
int      fscanf(FILE *restrict stream, const char *restrict format, ...);
int      fseek(FILE *stream, long offset, int whence);
int      fseeko(FILE *stream, off_t offset, int whence);
int      fsetpos(FILE *stream, const fpos_t *pos);
long     ftell(FILE *stream);
off_t    ftello(FILE *stream);
int      ftrylockfile(FILE *stream);
void     funlockfile(FILE *stream);
size_t   fwrite(const void *restrict ptr, size_t size, size_t nmemb, FILE *restrict stream);
int      getc(FILE *stream);
int      getchar(void);
int      getc_unlocked(FILE *stream);
int      getchar_unlocked(void);
ssize_t  getdelim(char **restrict lineptr, size_t *restrict n, int delimiter, FILE *restrict stream);
ssize_t  getline(char **restrict lineptr, size_t *restrict n, FILE *restrict stream);
char    *gets(char *s);
FILE    *open_memstream(char **bufptr, size_t *sizeptr);
int      pclose(FILE *stream);
void     perror(const char *s);
FILE    *popen(const char *command, const char *mode);
int      printf(const char *restrict format, ...);
int      putc(int c, FILE *stream);
int      putchar(int c);
int      putc_unlocked(int c, FILE *stream);
int      putchar_unlocked(int c);
int      puts(const char *str);
int      remove(const char *filename);
int      rename(const char *old_filename, const char *new_filename);
int      renameat(int old_fd, const char *old_path, int new_fd, const char *new_path);
void     rewind(FILE *stream);
int      scanf(const char *restrict format, ...);
void     setbuf(FILE *restrict stream, char *restrict buffer);
int      setvbuf(FILE *restrict stream, char *restrict buffer, int mode, size_t size);
int      snprintf(char *restrict str, size_t size, const char *restrict format, ...);
int      sprintf(char *restrict str, const char *restrict format, ...);
int      sscanf(const char *restrict str, const char *restrict format, ...);
char    *tempnam(const char *dir, const char *prefix);
FILE    *tmpfile(void);
char    *tmpnam(char *s);
int      ungetc(int c, FILE *stream);
int      vdprintf(int fd, const char *restrict format, va_list ap);
int      vfprintf(FILE *restrict stream, const char *restrict format, va_list ap);
int      vfscanf(FILE *restrict stream, const char *restrict format, va_list ap);
int      vprintf(const char *restrict format, va_list ap);
int      vscanf(const char *restrict format, va_list ap);
int      vsnprintf(char *restrict str, size_t size, const char *restrict format, va_list ap);
int      vsprintf(char *restrict str, const char *restrict format, va_list ap);
int      vsscanf(const char *restrict str, const char *restrict format, va_list ap);

```
---
## Windows "Cheat Sheet" for Programmers

### File I/O

- **File Paths:**
  - Uses backslashes (`\`) as separators.
  - Drive letters (e.g., `C:\Windows\System32`).
  - Environment variables: Use `%VARIABLE_NAME%`.
- **fopen, fread, fwrite, etc.:**
  - Largely function the same way as their POSIX counterparts.
  - Specific text vs. binary handling modes available ('t' vs. 'b').
- **Preferred Alternatives:**
  - Consider the Windows API functions like `CreateFile`, `ReadFile`, `WriteFile` for greater control over file handles and low-level I/O.

### Standard Input, Output, Error (stdin, stdout, stderr)

- **Handles:** Windows uses file handles instead of raw file descriptors.
    - `GetStdHandle(STD_INPUT_HANDLE)`
    - `GetStdHandle(STD_OUTPUT_HANDLE)`
    - `GetStdHandle(STD_ERROR_HANDLE)`
- **Console I/O:**
    - `ReadConsole`, `WriteConsole` for text console interaction.
- **File-like Usage:** You can often map standard file handles to some functions that expect POSIX-style file descriptors. This is not universally safe!

### Process Management

- **Process Creation:** 
  - `CreateProcess` is the primary way to launch new processes. 
  - More complex than POSIX `fork`/`exec` model.
- **Pipes:**
  - Windows has named pipes with some different semantics compared to POSIX pipes.
  - Used via `CreateNamedPipe`, `ConnectNamedPipe`.

### Threads

- **Thread Creation:** `CreateThread` for starting new threads.
- **Synchronization:**  
  - Uses critical sections, mutexes, semaphores (e.g., `EnterCriticalSection`, `CreateMutex`). 

### Windows-Specific Concepts

- **Windows Registry:** Hierarchical database for system and application settings. Use functions like `RegOpenKeyEx`, `RegSetValueEx`.
- **Windows Services:** Applications running in the background. Use the Service Control Manager API.
- **COM (Component Object Model):** Framework for creating reusable software components.
- **.NET Framework / .NET Core:** Managed development environments; provide a large class library distinct from traditional Win32/C++.

### Notable Exceptions

- **

Signal Handling:** Windows does not have direct equivalents to POSIX signals. You'll need structured exception handling (`__try __except`) or Windows-specific mechanisms.
- **fork():** Windows has no `fork()`. Use `CreateProcess` strategically for launching additional processes.  
- **POSIX-Specific functions:** Many functions with a `p` in their name (`pthreads`, functions specific to pipes) may not have exact equivalents.

## EXAMPLES  

Practical examples where portable alternatives might not suffice, focusing on scenarios that are unique to Windows or where Windows-specific APIs provide functionalities that standard C/C++ libraries do not cover. These examples will demonstrate how to use Windows-specific features effectively in situations where portable alternatives fall short.

### 1. Advanced File I/O Operations

In scenarios requiring detailed control over file access, sharing, security attributes, or asynchronous I/O operations, the Windows API functions like `CreateFile`, `ReadFile`, `WriteFile`, and `Overlapped I/O` offer capabilities beyond what is available through standard C `fopen`, `fread`, and `fwrite`.

**Example: Creating a file with specific security attributes and asynchronous access**

```c
#include <windows.h>

void CreateFileExample() {
    HANDLE fileHandle;
    SECURITY_ATTRIBUTES secAttributes;

    secAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    // Use default security descriptor.
    secAttributes.lpSecurityDescriptor = NULL; 
    // Allow handle to be inherited.

    secAttributes.bInheritHandle = TRUE; 
    fileHandle = CreateFile(
        TEXT("example.txt"), // File name
        GENERIC_WRITE,       // Desired access (write access)
        0,                   // No sharing
        &secAttributes,      // Security attributes
        CREATE_NEW,          // Creation disposition
        FILE_FLAG_OVERLAPPED,// Flags/attributes (async I/O)
        NULL                 // No template file
    );

    if (fileHandle == INVALID_HANDLE_VALUE) {
        // Handle error condition
    }

    // Use fileHandle for asynchronous I/O operations...
    // Always close the handle when done.
    CloseHandle(fileHandle); 
}
```

### 2. Direct Console I/O

For applications that need direct control over the console (e.g., for writing Unicode characters or handling input/output in a non-standard way), `ReadConsole` and `WriteConsole` provide functionalities not available through `stdin`/`stdout`.

**Example: Writing Unicode text to the console**

```c
#include <windows.h>

void WriteUnicodeToConsole() {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    WCHAR text[] = L"Hello, 世界"; // Unicode text

    WriteConsole(hConsole, text, wcslen(text), NULL, NULL);
}
```

### 3. Process Creation and Management

When you need to create a process with specific starting conditions, environment variables, or startup information, `CreateProcess` offers a level of detail and control that cannot be matched by portable alternatives like `system()` or the POSIX `fork` and `exec`.

**Example: Launching a new process with custom environment and starting directory**

```c
#include <windows.h>

void CreateProcessExample() {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    // Set up environment block, startup directory, or other specific settings...

    if (!CreateProcess(
            TEXT("C:\\notepad.exe"),    // Application name
            NULL,                       // Command line
            NULL,                       // Process security attrs
            NULL,                       // Primary thread security attrs
            FALSE,                      // Handles are not inherited
            0,                          // Creation flags
            NULL,                       // Use parent's env block
            NULL,                       // Use parent's start dir
            &si,                        // Ptr to STARTUPINFO struct
            &pi                         // Ptr to PROCESS_INFORMATION struct
        )) {
        // Handle error condition
    }

    // Close process and thread handles when done
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}
```

### 4. Advanced Synchronization Techniques

In situations requiring complex synchronization among threads or processes, Windows offers a wide range of synchronization primitives like `Mutexes`, `Events`, `Semaphores`, and `Waitable Timers`, which provide capabilities beyond what is available through portable threading libraries.

**Example: Using a mutex to synchronize access to a resource**

```c
#include <windows.h>

HANDLE mutex;

void Initialize() {
    // Create a named mutex.
    mutex = CreateMutex(NULL, FALSE, TEXT("MyMutex"));
}

void ThreadFunction() {
    // Wait for the mutex for up to 10 seconds.
    DWORD dwWaitResult = WaitForSingleObject(mutex, 10000); // 10-second wait

    switch (dwWaitResult) {
        // The thread got mutex ownership.
        case WAIT_OBJECT_0:
            // Access shared resource.

            // Release ownership of the mutex.
            ReleaseMutex(mutex);
            break;

        // The thread got ownership of an abandoned mutex.
        // The database is in an indeterminate state.
        case WAIT_ABANDONED:
            return;
    }
}

void Cleanup() {
    CloseHandle(mutex); // Always clean up handles.
}
```

## APPLICATION USAGE  

None.

## RATIONALE  

None.

## FUTURE DIRECTIONS  

This should provide a comprehensive guide for developers navigating between Linux and Windows environments, highlighting key differences and offering Windows-specific insights alongside the POSIX standards.
## SEE ALSO  

The System Interfaces volume of POSIX.1‐2017, `<stdarg.h>`, `<stddef.h>`, `<sys/types.h>`

The Base Definitions volume of POSIX.1‐2017, `<stdio.h>`

[fdopen](https://man7.org/linux/man-pages/man3/fdopen.3p.html), [feof](https://man7.org/linux/man-pages/man3/feof.3p.html)[ferror](https://man7.org/linux/man-pages/man3/ferror.3p.html), [fflush](https://man7.org/linux/man-pages/man3/fflush.3phtml), [fgetc](https://man7.org/linux/man-pages/man3/fgetc.3p.html), [fgetpos](https://man7.org/linux/man-pages/man3fgetpos.3p.html), [fgets](https://man7.org/linux/man-pages/man3/fgets.3p.html), [fileno](https://man7.org/linux/man-pagesman3/fileno.3p.html), [flockfile](https://man7.org/linux/man-pages/man3/flockfile.3p.html), [fmemopen](https://man7.orglinux/man-pages/man3/fmemopen.3p.html), [fopen](https://man7.org/linux/man-pages/man3/fopen.3p.html), [fprintf](https:/man7.org/linux/man-pages/man3/fprintf.3p.html), [fputc](https://man7.org/linux/man-pages/man3/fputc.3p.html), [fputs](https://man7.org/linux/man-pages/man3/fputs.3p.html), [fread](https://man7.org/linux/man-pages/man3/fread.3p.html)[freopen](https://man7.org/linux/man-pages/man3/freopen.3p.html), [fscanf](https://man7.org/linux/man-pages/man3/fscanf.3phtml), [fseek](https://man7.org/linux/man-pages/man3/fseek.3p.html), [fsetpos](https://man7.org/linux/man-pages/man3fsetpos.3p.html), [ftell](https://man7.org/linux/man-pages/man3/ftell.3p.html), [fwrite](https://man7.org/linux/man-pagesman3/fwrite.3p.html), [getc](https://man7.org/linux/man-pages/man3/getc.3p.html), [getchar](https://man7.org/linuxman-pages/man3/getchar.3p.html), [getc_unlocked](https://man7.org/linux/man-pages/man3/getc_unlocked.3p.html), [getdelim](https://man7.org/linux/man-pages/man3/getdelim.3p.html), [getopt](https://man7.org/linux/man-pages/man3/getopt.3p.html)[gets](https://man7.org/linux/man-pages/man3/gets.3p.html), [open_memstream](https://man7.org/linux/man-pages/man3open_memstream.3p.html), [pclose](https://man7.org/linux/man-pages/man3/pclose.3p.html), [perror](https://man7.org/linuxman-pages/man3/perror.3p.html), [popen](https://man7.org/linux/man-pages/man3/popen.3p.html), [putc](https://man7.org/linuxman-pages/man3/putc.3p.html), [putchar](https://man7.org/linux/man-pages/man3/putchar.3p.html), [puts](https://man7.orglinux/man-pages/man3/puts.3p.html), [remove](https://man7.org/linux/man-pages/man3/remove.3p.html), [rename](https://man7org/linux/man-pages/man3/rename.3p.html), [rewind](https://man7.org/linux/man-pages/man3/rewind.3p.html), [setbuf](https:/man7.org/linux/man-pages/man3/setbuf.3p.html), [setvbuf](https://man7.org/linux/man-pages/man3/setvbuf.3p.html), [stdin](https://man7.org/linux/man-pages/man3/stdin.3p.html), [system](https://man7.org/linux/man-pages/man3/system.3p.html)[tempnam](https://man7.org/linux/man-pages/man3/tempnam.3p.html), [tmpfile](https://man7.org/linux/man-pages/man3/tmpfile3p.html), [tmpnam](https://man7.org/linux/man-pages/man3/tmpnam.3p.html), [ungetc](https://man7.org/linux/man-pages/man3ungetc.3p.html), [vfprintf](https://man7.org/linux/man-pages/man3/vfprintf.3p.html), [vfscanf](https://man7.org/linuxman-pages/man3/vfscanf.3p.html)

COPYRIGHT  

Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.opengroup.org/unix/online.html.
